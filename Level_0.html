<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>_alpha_</title>
<script src="src\js\three.js"></script>
<script src="src\js\OrbitControls.js"></script>
<script src="src\js\libs\stats.min.js"></script>
<script src="src\js\OBJLoader.js"></script>
<script src="src\js\MTLLoader.js"></script>
<script src="src\js\threex.cubecamera.js"></script>
<script src="src\js\threex.atmospherematerial.js"></script>
<script src="src\js\threex.atmospherematerialdatgui.js"></script>
<script src="src\js\threex.dilategeometry.js"></script>
<script src="src\js\threex.geometricglowmesh.js"></script>
<script src="src/js/GeometryUtils.js"></script>
<script src="src/js/BendModifier.js"></script>


<script src="src\alpha.js"></script>
<script src="src\map.js"></script>
<script src="src\menu.js"></script>
<script src="src\powerup.js"></script>
<script src="src\collectible.js"></script>

<script>

"use strict";

//Globals
var WORLD_WIDTH = 2000;
var WORLD_DEPTH = 2000;
var ATMOSPHERE_HEIGHT = 100;
var ALPHA_CAMERA_DISTANCE = 20;
var LEVEL = 0; //level variable mostly for display purposes at the moment
// var SAVE_EVERY_N_FRAMES = 200; // ACHTUNG: This may need adjusting depending on layout of buildings in level ad other stuff
var STARTING_LIVES = 3;
var NUM_LIGHTS = 2;

var canvas, renderer, scene, camera; // Standard three.js requirements.

var container, stats;

var controls;  // An OrbitControls object that is used to implement
               // rotation of the scene using the mouse.  (It actually rotates
               // the camera around the scene.)

var fullscreen = false;
var animating = false;  // Set to true when an animation is in progress.
var frameNumber = 0;  // Frame number is advanced by 1 for each frame while animating.

var player = new THREE.Object3D();

var keys = []; //records current keys being pressed

var resetCameraFlag = false //flag to reset the camera position to original position

var jumping = false;	//whether player is jumping or not

var alpha;	// player stats tracking + model  object

var gameOver = false; //updates to true when lives == 0

var worldMap; // make global so it can be accessed by collision function

var powerups = [];	

var collideMeshArray = []; // array to store  all collidable mesh's (buildings + items)

var powerups = [];			// items providing certain powerups or "boosts" to the player for a short time when picked up
var activePowerup = null;
var collectibles = [];			// the items that the player needs to collect in order to progress to the next level
//var collectiblesLeft = 0;			// the number of collectibles left to collect. when this reaches zero, go to next level
var mixer = null;  // The object that animates the model, of type THREE.AnimationMixer

var minimapCamera, minimapWidth = window.innerHeight/5, minimapHeight = window.innerHeight/5; //

var worldMap;

var last_position; // Save last legal position of player. Used in respawning process Gets updated every +- 10 (?) legal positions

var mesh;

var cubeCamera;

var joshSucks; // he does

var Score = 0;

/// TODO: Put these with global vars or somewhere else
var text = "JOSH  SUCKS",
	height = 0.5,
	size = 2,
	curveSegments = 4,
	font = undefined;
var group, textMesh1, textGeo, materials;

var menu = new Menu(ALPHA_CAMERA_DISTANCE * 2, "textures/skyboxes/tantolunden5/", "sprites/buttons/");



/**
 *  The render function draws the scene.
 */
function render() {
	var w = window.innerWidth, h = window.innerHeight;
	renderer.setSize(w,h);

	// Render main camera on entire screen
	renderer.setViewport( 0, 0, w, h );
	renderer.setScissor( 0, 0, w, h );
	renderer.setScissorTest( true );
	camera.aspect = w / h;
	camera.updateProjectionMatrix();
    renderer.render(scene, camera);
	
	//add objects to minimap so it will be easier to see

	//add sphere for player
	var arrow = new THREE.Mesh(
		new THREE.SphereGeometry( 20 ),
		new THREE.MeshBasicMaterial( {color: 0xffff00} )	
	);
	arrow.translateX(player.position.x - arrow.position.x);
	arrow.translateZ(player.position.z - arrow.position.z);
	arrow.translateY(ATMOSPHERE_HEIGHT - 88);
	scene.add(arrow);

	var minimapPowerups = [];
	for (var i = 0; i < powerups.length; i++){
		var powerupCube = new THREE.Mesh(
			new THREE.BoxGeometry( 30, 30, 30 ),
			new THREE.MeshBasicMaterial( {color: 0xff0000} )
		);
		
		powerupCube.translateX(powerups[i].position.x - powerupCube.position.x);
		powerupCube.translateZ(powerups[i].position.z - powerupCube.position.z);
		powerupCube.translateY(ATMOSPHERE_HEIGHT - 90);
		minimapPowerups.push(powerupCube);

		scene.add(powerupCube);
	} 

	// Render minimap camera in top right corner
	renderer.setViewport( w - minimapWidth - 50, 20, minimapWidth, minimapHeight );
	renderer.setScissor( w - minimapWidth - 50, 20, minimapWidth, minimapHeight );
	renderer.setScissorTest( true ); //important for minimap not to take control of entire screen even though it only occupies a corner
	minimapCamera.aspect = w / h;
	minimapCamera.updateProjectionMatrix();
	renderer.render( scene, minimapCamera );

	//romve arrow from scene
	scene.remove(arrow);

	for (var i = 0; i < powerups.length; i++){
		scene.remove(minimapPowerups[i])
	}
}

function respawnAlpha(){
	var currLives = alpha.lives;
	while(true){
		console.log("respawning alpha");
		var randomX = Math.random();
		var randomZ = Math.random();
		player.position.set(randomX * (worldMap.width / 2), 0, randomZ * (worldMap.depth / 2));
		minimapCamera.position.set(randomX * (worldMap.width / 2), 0, randomZ * (worldMap.depth / 2));
		collissions();
		if(alpha.lives != currLives){
			alpha.lives = currLives;
		} else {
			break;
		} 
	}
	alpha.resetAttributes();
}

//make sure alpha doesn't spawn on an object
// this function gets called as a callback for when alpha finishes loading and for when map buildings get loaded
var alphaDone = false;
var mapDone = false;
function alphaStartup(){
	if(alphaDone && mapDone){
		console.log("checking if alpha initialized on building");
		collissions();
		alpha.lives = STARTING_LIVES;
	}
}

/**
 * This function is called by the init() method to create the world. 
 */
function createWorld() {
    
    renderer.setClearColor("black"); // Background color for scene.
    scene = new THREE.Scene();
    
    // ------------------- Make a camera with viewpoint light ----------------------
    
    camera = new THREE.PerspectiveCamera(
		30, 
		window.innerWidth/window.innerHeight, 
		0.1, 
		ALPHA_CAMERA_DISTANCE * 20//Math.sqrt(Math.pow(WORLD_WIDTH,2) + Math.pow(WORLD_DEPTH, 2))
	);
    camera.position.z = ALPHA_CAMERA_DISTANCE;

	//------------------------------------- LIGHTING ------------------------------------------------
	for(var i = 0; i < NUM_LIGHTS; i++){
		var light = new THREE.PointLight(0xffffff, 1, 1000000);
		light.position.set(
			Math.pow(-1, Math.floor(Math.random() * 2) + 1) * WORLD_WIDTH / (6 + Math.random() * 10),
			ATMOSPHERE_HEIGHT * (1 + Math.random()), 
			Math.pow(-1, Math.floor(Math.random() * 2) + 1) * WORLD_WIDTH / (6 + Math.random() * 10)
		);

		//shadows for light 1
		light.castShadow = true;
		light.shadowDarkness = 0.5;
		//Set up shadow properties for the light
		light.shadow.mapSize.width = WORLD_WIDTH;  
		light.shadow.mapSize.height = WORLD_DEPTH; 
		light.shadow.camera.near = 0.5;    // default
		light.shadow.camera.far = Math.sqrt(Math.pow(ATMOSPHERE_HEIGHT,2) + Math.pow(Math.pow(WORLD_WIDTH,2) + Math.pow(WORLD_DEPTH,2),2));     // Pythagoras equation for edge to edge diagonal of livable map cube

		scene.add(light);
	}

	//Create a helper for the shadow camera (optional)
	//var lightHelper = new THREE.CameraHelper( light1.shadow.camera );
	//scene.add( lightHelper );

    player.add(camera);
    scene.add(player);
    
	//---------------------- Minimap ----------------------------------------------
	minimapCamera = new THREE.OrthographicCamera(
	    window.innerHeight / -5,						// Left
		window.innerHeight / 5,							// Right
    	window.innerHeight / 5,							// Top
    	window.innerHeight / -5,						// Bottom
    	-1 * ATMOSPHERE_HEIGHT + 0.001,					// Near 
    	10000 );           								// Far 
	minimapCamera.up = new THREE.Vector3(0,0,-1);
	minimapCamera.lookAt( new THREE.Vector3(0,-1,0) );

	scene.add(minimapCamera);


    //---------------------------------- CREATE THE WORLD -------------------------------------------
    

	worldMap = new Map(WORLD_WIDTH, WORLD_DEPTH, ATMOSPHERE_HEIGHT, "textures/floor.jpg", "textures/skyboxes/dawnmountain/") //width, height, atmosphereHight, textureURL, skyboxDirectory
	scene.add(worldMap.floor);
	scene.background = worldMap.skybox;
	scene.add(worldMap.atmosphere);	

	//add buildings to scene
	worldMap.createBuildings(0.5); //map-buildings ratio is 1/2

	for (var i = 0; i < worldMap.buildings.length; i++){
		scene.add(worldMap.buildings[i]);
	}




	
	//---------------------------------- CUBE MAP OBJECT THING// TODO: DECIDE WHERE TO PUT THIS and CLEAN IT UP and TRY using NOT THREEx OR maybe keep it if Richard gives points for using extensions??--------------------------------------
	// try using https://threejs.org/examples/#webgl_materials_cubemap_dynamic2


	// resources: http://learningthreejs.com/blog/2014/05/12/live-cube-maps-reflections-in-your-three-dot-js-game-with-threex-dot-cubecamera/
	joshSucks = new THREE.Object3D();

	var geometry = new THREE.SphereGeometry(5, 32, 16);
	var material = new THREE.MeshPhongMaterial({
    color   : 'chrome',
	envMap 	: scene.background
	});
	mesh = new THREE.Mesh(geometry, material);
	//mesh.scale.set(5,10,10);
	mesh.position.set(0,0,0);	// centre obj coords of sphere
	scene.add(mesh);

	// using cubecamera.js library. Don't know if this is legal
 	//cubeCamera  = new THREEx.CubeCamera(mesh);
	//scene.add(cubeCamera.object3d);

	//material.envMap = cubeCamera.textureCube;
	joshSucks.add(mesh);

	// GLOW THING
	// Source: https://github.com/jeromeetienne/threex.geometricglow
		

//////////////////////////////////////////////////////////////////////////////////
//		add  text	 														//
///	///////////////////////////////////////////////////////////////////////////////
	group = new THREE.Group();
	group.position.set(-8,0,10);	// obj translation of text object onto sphere. Currently doesn't reflect close objects nicely 

	//scene.add( group );
	loadFont();	// create the text object
	console.log("Loadfont was called");	
	joshSucks.add(group);
	joshSucks.position.set(3,3,-30);
	scene.add(joshSucks);




	//----------------------------------- CREATE THE PLAYER --------------------------------------------

// alpha is created by model_loader function and added to player
	
	var loader = new THREE.JSONLoader();					// create loader for .js models
	loader.load("models/stork.js", model_loader);		// load model and call model_loader
	


	var gun = new Powerup("gun");	// add a gun powerup
	gun.position.set(3,4,3);
	powerups.push(gun);

	var inv = new Powerup("invisible");	// add invisibility powerup
	inv.position.set(10,6,10);
	powerups.push(inv);

	var grav = new Powerup("gravity");	// add a gravity powerup
	grav.position.set(0,3,-16);
	powerups.push(grav);

	for(var i = 0; i < powerups.length; i++){
		scene.add(powerups[i]);
	} 
	
	var collectible0 = new Collectible(
		new THREE.CylinderGeometry(1,0.5,1,32),
		new THREE.MeshPhongMaterial({color: 0xff00ff})
	);
	collectible0.position.set(-7,5,3);
	collectibles.push(collectible0);
	
	var collectible1 = new Collectible(
		new THREE.CylinderGeometry(1,0.5,1,32),
		new THREE.MeshPhongMaterial({color: 0x00ffff})
	);
	collectible1.position.set(7,3,-4);
	collectibles.push(collectible1);
	
	for (var j = 0; j < collectibles.length; j++) {
		scene.add(collectibles[j]);
	}

} // end function createWorld()




/*<<<<<<<<<<<<<<<<<<<<<< C U S T O M 	S U B   R O U T I N E S >>>>>>>>>>>>>>>>>>>>>>>>>>>
			                                 |_
			                           _____|~ |____
			                          (  --         ~~~~--_,
			                           ~~~~~~~~~~~~~~~~~~~'`  

*/

/*///////////////////////////////////////////////////////////////////////////////// 
Reset the camera's to be behind the player (chase cam), after viewing the world.
//////////////////////////////////////////////////////////////////////////////////*/

function resetCameraPosition(){
	var cameraRotationSpeed = 0.1;
	camera.translateX((alpha.position.x - camera.position.x) * cameraRotationSpeed);
	camera.translateY((alpha.position.y - camera.position.y) * cameraRotationSpeed);
	camera.translateZ((alpha.position.z + ALPHA_CAMERA_DISTANCE - camera.position.z) * cameraRotationSpeed);
	camera.lookAt(alpha.position);

	if(Math.abs(alpha.position.x - camera.position.x) <= 0.01 &&
		Math.abs(alpha.position.y - camera.position.y <= 0.01) &&
		Math.abs(alpha.position.z + ALPHA_CAMERA_DISTANCE - camera.position.z <= 0.01)){
		
		resetCameraFlag = false;
	}
}

function exitMenu(){
	scene.remove(menu.skybox);
	for(var i = 0; i< menu.buttons.length; i++){
		scene.remove(menu.buttons[i]);
	}
	document.removeEventListener("mousedown", menuInteraction);
}
/*//////////////////////////////////////////////////////////////////////////////////////////
Waiting for user input while in menu mode
///////////////////////////////////////////////////////////////////////////////////////////*/
function menuInteraction(e){
	var raycaster = new THREE.Raycaster();
	
	//var r = window.getBoundingClientRect();
	var x = e.clientX// - r.left; // convert mouse location to canvas pixel coords
	var y = e.clientY// - r.top;

	var a = 2 * x / window.innerWidth - 1; // convert canvas pixel coords to clip coords
	var b = 1 - 2 * y / window.innerHeight;

	console.log("aaaaaaaaaaa " + a + " bbbbbbbbbbbb " + b);
	raycaster.setFromCamera( new THREE.Vector2(a,b), camera );

	var intersections = raycaster.intersectObjects( menu.buttons, true );
	if(intersections.length >= 1){
		if(intersections[0].object.name == "restart_button"){
			console.log("restarting game");
		} else if (intersections[0].object.name == "resume_button"){
			console.log("resuming game");
			exitMenu();
		} else if(intersections[0].object.name == "exit_button"){
			window.alert("This is, sadly, a web game.\nIf you want to close it you are welcome to close this browser tab.\nJust know that it cannot be proven that exiting this game will not result in you being dead one month later\nYou have been warned");
		}
	}
}

/*////////////////////////////////////////////////////////////////////////////////
Display pause menu
/////////////////////////////////////////////////////////////////////////////////*/
function displayMenu(){
	menu.skybox.position.x = player.position.x;
	menu.skybox.position.y = player.position.y;
	menu.skybox.position.z = player.position.z;
	scene.add(menu.skybox);

	for(var i = 0; i < menu.buttons.length; i++){
		menu.buttons[i].position.x = player.position.x + Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * ((ALPHA_CAMERA_DISTANCE * 2 - 5) / 2);
		menu.buttons[i].position.y = player.position.y + Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * ((ALPHA_CAMERA_DISTANCE * 2 - 5) / 2);
		menu.buttons[i].position.z = player.position.z + Math.random() * ((ALPHA_CAMERA_DISTANCE * 2 - 5) / 2);

		scene.add(menu.buttons[i]);
	}

	console.log("displaying menu...");

	document.addEventListener("mousedown", menuInteraction, false);
}

/*//////////////////////////////////////////////////////////////////////////
 Keyboard key lookups:  Check arrow, a,w,s,d and space keys
///////////////////////////////////////////////////////////////////////////*/

window.addEventListener("keydown", keysPressed, false);
window.addEventListener("keyup", keysReleased, false);

function key_check(){
	//keycodes taken from: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes	

	// Up Arrow or "w" - camera moves forwad = speed up
	if(keys[38] || keys[87]){ 
		alpha.incSpeedZ(-0.05);
	}
    // Down Arrow or "s" - camera moves back = speed down
    if(keys[40] || keys[83]){  
		alpha.incSpeedZ(0.05);
	}

    // a key: strafe left
    if (keys[65]) {     
        player.translateX(-0.2);
    }

    // d key: strafe right
    if (keys[68]) {     
        player.translateX(0.2);
    }

    // right arrow: turn right
    if (keys[39]) {     
        player.rotateY(-1 * Math.PI/180);
		minimapCamera.rotateZ(-1 * Math.PI/180);
    }

    // left arrow: turn left
    if (keys[37]) {     
        player.rotateY(Math.PI/180);
		minimapCamera.rotateZ(Math.PI/180) ;
    }

   // space key: fight gravity
   if (keys[90]) {     
		if (!jumping) {			// Set limit on jumping
			alpha.incSpeedY(1);
		}
		jumping = true;
    }
}

// This function gets called when a key is pressed
function keysPressed(e) {
	// "p" for pause and play           
	if(e.keyCode == 80){
		if(!animating){
			exitMenu();
			animating = true;
			requestAnimationFrame(doFrame);
		} else {
			animating = false;
			displayMenu();
		}
		return;
	}

	// F11 to enter and exit fullscreen
	if(e.keyCode == 122){
		if(!fullscreen){
			fullscreen = true;
			document.requestFullscreen();
		} else {
			fullscreen = false
			document.exitFullscreen();
		}
		return;
	}

	// F5 to refresh page
	if(e.keyCode == 116){
		window.location.reload(false); 
		return
	}
	
    // store an entry for every key pressed
    keys[e.keyCode] = true;
        // NB: prevent default browser behavior - disable during testing
        e.preventDefault();
}

function keysReleased(e) {
    // mark keys that were released
    keys[e.keyCode] = false;
    if (e.keyCode == 90) {
		jumping = false;
	}
}


/*//////////////////////////////////////////////////////////////////////////
Put player on the floor
///////////////////////////////////////////////////////////////////////////*/
function put_on_floor() {
	if(player.position.y > -2 + alpha.getRadius()) {	//check if player has reached the "floor"
		alpha.incSpeedY(-0.01);				//if they have not, reduce speed (gravity)
	} else {						//if they have, stop reducing speed and set position to the ground, set Y speed to zero
		alpha.setSpeedY(0);
		player.position.y = -2 + alpha.getRadius();
	}	
}



/*//////////////////////////////////////////////////////////////////////////
Model Loader
///////////////////////////////////////////////////////////////////////////*/

function model_loader(geometry, materials) {

	var material = new THREE.MeshLambertMaterial( {
        vertexColors: THREE.FaceColors,  	// use colors from the geometry
        morphTargets: true							// for animation
    });

// Testing geometry
       // var geom2= new THREE.BoxGeometry(10,10,10);
       //  var mar2 = new THREE.MeshPhongMaterial({
       //      color: 0xFF0000,
       //      specular: 0x222222,
       //      shininess: 16
       //      //shading: THREE.FlatShading
       //  });
    
	alpha = new Alpha(geometry,material, 1);	// create alpha object
	
// TRANSFORMS

	alpha.scale.set(0.05,0.05,0.05);
	alpha.position.set(0,-2,0);
	alpha.rotateY(Math.PI);
	alpha.castShadow = true;
	player.add(alpha);				// add alpha to player

	alpha.geometry.computeBoundingBox();
	alphaDone = true;
	alphaStartup();	

// ANIMATION STUFF
	
	mixer = new THREE.AnimationMixer( alpha );
	var clip = THREE.AnimationClip.CreateFromMorphTargetSequence( 'motion', geometry.morphTargets, 30 );
    var animationAction = mixer.clipAction(clip);
    animationAction.setDuration(1);
    animationAction.play(); 
	render();
}



/*//////////////////////////////////////////////////////////////////////////
Respawn: Reset player position, reset alpha speed 
///////////////////////////////////////////////////////////////////////////*/
function Respawn(){
	animating = false;
	// reset player position to legal position, N frames ago (checkpoint kinda):
	player.position.set(last_position.x,last_position.y,last_position.z);
	console.log("player",player.position.x, player.position.y, player.position.z);
	
	// reset alpha speed
	alpha.setSpeedZ(-0.01);	// We should probably have a static variable for this
	alpha.setSpeedY(0);
	animating = true;	
	// 
}



/*//////////////////////////////////////////////////////////////////////////
Save Position: Saves players legal position every N frames. avi_respawn
///////////////////////////////////////////////////////////////////////////*/
// function SavePosition(){
// 	if (everyNframes == SAVE_EVERY_N_FRAMES){
// 		// Do stuff:
// 		console.log("N counter: ", everyNframes);
// 		// - Store position of player
// 		last_position = player.position.clone(); // may need to be player.position.clone()
// 		console.log("last position",last_position);
// 		// Reset to everyNframes counter to 0
// 		everyNframes = 0;
// 		console.log("N counter: ", everyNframes);

// 	}else{ 
// 		return; // necessary ??
// 	}
// }




/*//////////////////////////////////////////////////////////////////////////
Crash: Explosion, respawn from crash site, decrement lives, game over
///////////////////////////////////////////////////////////////////////////*/
function Crash() {
	// Update Alpha stats
	alpha.lives -= 1;
	// if no more lives, game over
	if (alpha.lives == 0){
		gameOver = true;
		window.alert("G A M E    O V E R");
		//do other stuff
	}else{
	// TODO : Crash animation, respawn
		// Respawn(); //avi_respawn
		console.log("alpha crashed...");
		animating = false;
		window.alert("C R A S H E D!\n Lives left: " + alpha.lives);
		respawnAlpha();
	// respawning:
	// player.position = legal position
	// 
	}

}



/*//////////////////////////////////////////////////////////////////////////
Collisions!
///////////////////////////////////////////////////////////////////////////*/

//check for collision between two bounding boxes
//note bounding boxes have min: x,y,z, and max: x,y,z values
function twoBoxCollision(box1, box2){
	if(
		(box1.max.x < box2.min.x || box1.min.x > box2.max.x) ||
		(box1.max.y < box2.min.y || box1.min.y > box2.max.y) ||
		(box1.max.z < box2.min.z || box1.min.z > box2.max.z) 
	){
		return false;
	}
	return true;
}


//this function checks for collision of bounding boxes of alpha nd the map buildings
function alphaBoxCollision(){
	var suspectObjects = [];
	var alphaBox = new THREE.Box3();
    alphaBox.setFromObject( alpha );

	for(var i = 0; i < worldMap.buildingBoxes.length; i++){
		if(twoBoxCollision(worldMap.buildingBoxes[i], alphaBox)){
			suspectObjects.push(worldMap.buildings[i]);
		}
	}
	return suspectObjects;
}


//This must be called in updateFrame
// credit to Lee Stemkoski for his tutorial
// insert link to page
function  collissions() {
	var originPoint = player.position.clone();	// players position
	var suspectObjects = alphaBoxCollision();

	for (var vertexIndex = 0; vertexIndex < alpha.geometry.vertices.length; vertexIndex++){		
		var localVertex = alpha.geometry.vertices[vertexIndex].clone();
		var globalVertex = localVertex.applyMatrix4( alpha.matrix );
		var directionVector = globalVertex.sub( alpha.position );
		
		var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
		
		// Check building collisions
		var BuildingCollisionResults = ray.intersectObjects( suspectObjects , true );
		
		// Check Powerups[] collisions
			// TODO
		var PowerupsCollisionResults = ray.intersectObjects(powerups);
		
		var CollectibleCollisionResults = ray.intersectObjects(collectibles);
		if ( 
			BuildingCollisionResults.length > 0 &&
			BuildingCollisionResults[0].distance < directionVector.length() - 1 &&
			!BuildingCollisionResults[0].point.equals(new THREE.Vector3(0,0,0))
		){ // TODO: adjust this offset (-1 currently)
			console.log("hit");
			Crash();
			break;
		}
		//TODO: if powerup 0,1,2 do stuff to alpha.stats, delete power up from powerupsarray,and remove from scene (maybe with a fancy animation)
		if (PowerupsCollisionResults.length > 0 && PowerupsCollisionResults[0].distance < directionVector.length()){
			//Check what type of powerup it was
			if(PowerupsCollisionResults[0].object.type == powerupTypes["gun"]){
				console.log("Gun"); //TODO: update alpha stats
			}else if(PowerupsCollisionResults[0].object.type == powerupTypes["invisible"]){
				console.log("Invisible"); //TODO: update alpha stats
			}else if(PowerupsCollisionResults[0].object.type == powerupTypes["gravity"]){
				console.log("Gravity"); //TODO: update alpha stats
			}
			
			PowerupsCollisionResults[0].object.activatePower();
			activePowerup = PowerupsCollisionResults[0].object;
			powerups.splice(powerups.indexOf (PowerupsCollisionResults[0].object), 1 );
			scene.remove(PowerupsCollisionResults[0].object);
		}
		
		if ( CollectibleCollisionResults.length > 0 && CollectibleCollisionResults[0].distance < directionVector.length() ){ 
			console.log(collectibles.indexOf (CollectibleCollisionResults[0].object) );
			collectibles.splice(collectibles.indexOf (CollectibleCollisionResults[0].object), 1 );
			scene.remove(CollectibleCollisionResults[0].object);
			
			if(collectibles.length == 0) {
				window.alert( "You won the level!");
				//TODO: win the level if all collectibles collected
			}
		}

	}// end for loop	

} // end collision function



/*//////////////////////////////////////////////////////////////////////////
Fucking Text!
///////////////////////////////////////////////////////////////////////////*/


materials = [
	new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ), // front
	new THREE.MeshPhongMaterial( { color: 0xffffff } ) // side
];
// get the font then run create text fn
function loadFont() {

	var loader = new THREE.FontLoader();
	loader.load( 'fonts/Etienne/helvetiker_regular.typeface.js', function ( response ) {

		font = response;
		createText();
		console.log("loadFont()");

	} );

}

// create text fn
function createText() {
	console.log("createText()");
	textGeo = new THREE.TextGeometry( text, {
		font: font,
		size: size,
		height: height,
		curveSegments: curveSegments
	});

	textGeo.computeBoundingBox();
	textGeo.computeVertexNormals();

	// "fix" side normals by removing z-component of normals for side faces
	// (this doesn't work well for beveled geometry as then we lose nice curvature around z-axis)
	var triangleAreaHeuristics = 0.1 * ( height * size );

	for ( var i = 0; i < textGeo.faces.length; i ++ ) {

		var face = textGeo.faces[ i ];

		if ( face.materialIndex == 1 ) {

			for ( var j = 0; j < face.vertexNormals.length; j ++ ) {

				face.vertexNormals[ j ].z = 0;
				face.vertexNormals[ j ].normalize();

			}

			var va = textGeo.vertices[ face.a ];
			var vb = textGeo.vertices[ face.b ];
			var vc = textGeo.vertices[ face.c ];

			var s = THREE.GeometryUtils.triangleArea( va, vb, vc );

			if ( s > triangleAreaHeuristics ) {

				for ( var j = 0; j < face.vertexNormals.length; j ++ ) {

					face.vertexNormals[ j ].copy( face.normal );

				}
			
			}

		}

	}

	var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

	textMesh1 = new THREE.Mesh( textGeo, materials );

	// bend the text - this took hours to figure out because all the docs and examples are deprecated - FUCK
	// Had to modify a lib file (BendModifier.js)
	var direction = new THREE.Vector3( 0, 0, -1 );
	var axis =  new THREE.Vector3( 0, 1, 0 );
	var angle = Math.PI / 2.5;
	var modifier = new THREE.BendModifier();
	modifier.set( direction, axis, angle ).modify( textMesh1.geometry );


	group.add( textMesh1 );

	// create a glowMesh to make the text glow like neon
	var glowMesh	= new THREEx.GeometricGlowMesh(textMesh1);
	group.add(glowMesh.object3d);

}


///////////////////////////////////\				  //////////////////////////////
//================================== end sub routines =============================
///////////////////////////////////////////////////////////////////////////////////
/**
 *  This function is called once for each frame of the animation, before
 *  the render() function is called for that frame.  It updates any
 *  animated properties.  The value of the global variable frameNumber
 *  is incrementd 1 before this function is called.
 */
var everyNframes = 0; // Global counter to do stuff every Nth frame. 

function updateForFrame() {
	//Move player backwards or forwards by their Z velocity
    player.translateZ(alpha.getSpeedZ());	

    //Move player up or down by their Y velocity
	player.translateY(alpha.getSpeedY());

	// move minimap camera on x,z axis according to player
	// minimap height stays constant right and captures from right bellow the atmosphere
	minimapCamera.position.set(player.position.x, minimapCamera.position.y, player.position.z);	

	// Put player on floor if they aren't already on it.
	// TODO:Might need to update this for dying
	put_on_floor();

	// Slowly moving the camera back behind _alpha_
	if (resetCameraFlag){
		resetCameraPosition();
	}

	// Animate power-ups
	for(var i = 0; i < powerups.length; i++){
		powerups[i].animate();
	} 
	
//check if a power has been activated
	if(activePowerup != null) {
		if(activePowerup.getExpiration() < 0) {
			activePowerup.deactivatePower();
			activePowerup = null;
		} else {
			activePowerup.decrementExpiration();
		}
		
	}
	
	// animate collectibles
	for(var j = 0; j < collectibles.length; j++) {
		collectibles[j].animate();
	}

	// update model animation
	if(mixer) {
		mixer.update(0.02);
	}

	// camera can't got below floor
	if(new THREE.Vector3().setFromMatrixPosition(camera.matrixWorld).y < worldMap.floorHeight + 0.1){
		camera.position.y = worldMap.floorHeight + 1.1;
	}
	
	// Summon keyboard control lookups in one line.
	key_check(); 		

	// Increment Nth frame counter
	everyNframes ++;
	console.log("N counter: ",everyNframes);

	//Every N frames, save position.
	//SavePosition();	//avi_respawn

	//Collision
	collissions();	

	//animate josh sucks
	joshSucks.rotateY(Math.sin(Math.PI/6));

	// update cube map reflections. TODO: Only do this if the object is visible/ in 'range'
	//cubeCamera.update(renderer, scene);
	
	// Score update: TODO: ut in function and tidy up
	Score++;
 	document.getElementById("s1").innerHTML = "Score: " + Score;
 	document.getElementById("s2").innerHTML = "Lives: " + alpha.lives; // this will need to go in Crash function maybe


}


/* ---------------------------- MOUSE AND ANIMATION SUPPORT ------------------

/**
 *  This page uses THREE.OrbitControls to let the user use the mouse to rotate
 *  the view.  OrbitControls are designed to be used during an animation, where
 *  the rotation is updated as part of preparing for the next frame.  The scene
 *  is not automatically updated just because the user drags the mouse.  To get
 *  the rotation to work without animation, I add another mouse listener to the
 *  canvas, just to call the render() function when the user drags the mouse.
 *  The same thing holds for touch events -- I call render for any mouse move
 *  event with one touch.
 */
function installOrbitControls() {
    controls = new THREE.OrbitControls(camera,canvas);
    controls.noPan = true; 
    controls.noZoom = true;
    controls.staticMoving = true;
    function move() {
        controls.update();
        if (! animating) {
            render();
        }
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    document.addEventListener("mousedown", down, false);
    document.addEventListener("touchmove", touch, false);
}


// It determines _alpha_'s movements ("Space" with arrow keys or WASD). 
/*  Drives the animation, called by system through requestAnimationFrame() */
function doFrame() {
    if (animating) {
        frameNumber++;
        updateForFrame();
        render();
		stats.update();
        requestAnimationFrame(doFrame);
    }
}


/*----------------------------- INITIALIZATION ----------------------------------------

/**
 *  This function is called by the onload event so it will run after the
 *  page has loaded.  It creates the renderer, canvas, and scene objects,
 *  calls createWorld() to add objects to the scene, and renders the
 *  initial view of the scene.  If an error occurs, it is reported.
 */
function init() {
    try {
		container = document.getElementById( 'container' );
		document.getElementById("s0").innerHTML = "Level: " + LEVEL;
		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMap.enabled = true;
		//renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

		container.appendChild( renderer.domElement );

		stats = new Stats();
		container.appendChild( stats.dom );

    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
    createWorld();
    installOrbitControls();

	// keyboard controls
	// taken from: http://www.johannes-raida.de/tutorials/three.js/tutorial07/tutorial07.htm
	// multiple keypresses from: https://www.kirupa.com/html5/keyboard_events_in_javascript.htm
	document.addEventListener("mousedown", function(){resetCameraFlag = false}, false);
	document.addEventListener("mouseup", function(){resetCameraFlag = true}, false);	
    render();
}

</script>

<!-- CSS -->
<style>
.container {
    position: relative;
    text-align: center;
    color: black;
}

.bottom-left {
    position: absolute;
    bottom: 8px;
    left: 16px;
}

.top-left {
    position: absolute;
    top: 8px;
    left: 16px;
}

.top-right {
    position: absolute;
    top: 8px;
    right: 16px;
}

.bottom-right {
    position: absolute;
    bottom: 8px;
    right: 16px;
}

.centered {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.text-block {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background-color:rgba(192,192,192,0.5);
    color: white;
    padding-left: 20px;
    padding-right: 20px;
}

</style>


</head>
<body onload="init()">


	<noscript>
   		<p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
	</noscript>

	<p style="color:#AA0000; font-weight: bold" id="message"> </p>
 	<div class="container">
		<div id="container"></div>
	  	<div class="text-block">
	    	<h4>Stats</h4>
	    	<p id="s0"></p>
	    	<p id="s1">Score: NaN </p>
	    	<p id="s2">Lives: - / - </p>
	    </div>
	</div>

</body>
</html>
