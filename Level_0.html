<!DOCTYPE html>
<head>
<meta charset="UTF-8">
<title>_alpha_</title>
<script src="src\js\three.js"></script>
<script src="src\js\OrbitControls.js"></script>
<script src="src\js\libs\stats.min.js"></script>
<script src="src\js\OBJLoader.js"></script>
<script src="src\js\MTLLoader.js"></script>
<script src="src\js\threex.cubecamera.js"></script>
<script src="src\js\threex.atmospherematerial.js"></script>
<script src="src\js\threex.atmospherematerialdatgui.js"></script>
<script src="src\js\threex.dilategeometry.js"></script>
<script src="src\js\threex.geometricglowmesh.js"></script>
<script src="src/js/GeometryUtils.js"></script>
<script src="src/js/BendModifier.js"></script>
<script src="src/js/dat.gui.min.js"></script>


<script src ="src\level.js"></script>
<script src="src\alpha.js"></script>
<script src="src\map.js"></script>
<script src="src\menu.js"></script>
<script src="src\powerup.js"></script>
<script src="src\collectible.js"></script>

<script>

"use strict";


//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< G L O B A L    V A R I A B L E S >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

var canvas, renderer, scene, mainCamera; 	// Standard three.js requirements.

var currLevel = 0; 							//level variable mostly for display purposes at the moment

var level = new Level(currLevel, 2000, 2000, 100, 20, 3, 																							// levelNum, width, depth, atmosphereHeight, alphaCameraDistance, startingLives, 
				2, 0.5,['models/tree/tree', 'models/mill/mill'],  "models/stork.js", "textures/floor.jpg",					// numRandomLights, mapBuildingRatio, buildingModelURLs, alphaModelURL, floorTextureURL,
				"textures/skyboxes/dawnmountain/", 3, 3, [0,1,2], 																// backgroundURL, numPowerups, numCollectibles, powerups, 
				1, -10, -2, -0.01);																														// alphaMaxSpeedY, alphaMinSpeedY, alphaMaxSpeedZ, alphaMinSpeedZ

var container, stats;

var minimapCamera, minimapWidth = window.innerHeight/5, minimapHeight = window.innerHeight/5; //minimap variables

var controls;  											// An OrbitControls object that is used to implement
              											// rotation of the scene using the mouse.  (It actually rotates
               											// the camera around the scene.)

/* flags for different instances */
var fullscreen = false;

var animating = false;  					// Set to true when an animation is in progress.

var frameNumber = 0;  						// Frame number is advanced by 1 for each frame while animating.

var player = new THREE.Object3D();

var keys = []; 								// records current keys being pressed

var resetCameraFlag = false 				// flag to reset the camera position to original position

var jumping = false;						// whether player is jumping or not

var alpha;									// player stats tracking + model  object

var alphaDone = false;

var mapDone = false;

var Score = 0;

var activePowerup = null;

var menusArr = {};

var worldMap; 								// make global so it can be accessed by collision function

var collideMeshArray = []; 					// array to store  all collidable mesh's (buildings + items)

var powerups = [];							// items providing certain powerups or "boosts" to the player for a short time when picked up
var activePowerup = null;

var collectibles = [];						// the items that the player needs to collect in order to progress to the next level

var mixer = null;  							// The object that animates the model, of type THREE.AnimationMixer

var discoBall;

var joshSucks;								// he does

// for the text; there is no better way, sorry.
var textMesh1;
var font;
var text ;
var text_height ;
var text_size;
var curveSegments;	
//

var text_object_container;			

var i =0;									// iterator for doing object roation animation

// for menu class
//var menu = new Menu(ALPHA_CAMERA_DISTANCE * 2, "textures/skyboxes/tantolunden5/", "sprites/buttons/");



//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< I N I T I A L I S A T I O N   F U N C T I O N S >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
function createMenus(){
	var startMenu = new Menu(
			level.alphaCameraDistance * 2 * 2, 
			"textures/skyboxes/ulam/", 
			"sprites/buttons/", 
			["exit_button", "start_button"]
		);
	menusArr.startMenu = startMenu;
	var pauseMenu = new Menu(
			level.alphaCameraDistance * 2 * 2, 
			"textures/skyboxes/tantolunden5/", 
			"sprites/buttons/", 
			["exit_button", "restart_button", "resume_button"]
		);
		menusArr.pauseMenu = pauseMenu;
}



/* /////////////////////////////////////////////////////////////
	Renders the camera given as input
	Called by render
	INPUT: camera to render, left and top are top left corner to start rendering from, width and height are size arguments of renderer
	OUTPUT: none
 *//////////////////////////////////////////////////////////////
function cameraRender( camera, left, top, width, height ){
	
	renderer.setViewport( left, top, width, height );
	renderer.setScissor( left, top, width, height );
	camera.updateProjectionMatrix();
    renderer.render(scene, camera);
}



/* /////////////////////////////////////////////////////////////
	Places object markers above given object on minimap
	Called by addMinimapObjects
	INPUT: objectArray is an array of objects to put objects above, item is what to place above the object
	OUTPUT: array of objects added to scene
 *//////////////////////////////////////////////////////////////
function putAboveObject(objectArray, item){
	var newItemArray = new Array();
	for (var i = 0; i < objectArray.length; i++){
		var currItem = item.clone();
		currItem.translateX(objectArray[i].position.x - currItem.position.x);
		currItem.translateZ(objectArray[i].position.z - currItem.position.z);
		currItem.translateY(level.atmosphereHeight * 2);
		scene.add(currItem);

		newItemArray.push(currItem);
	}
	return newItemArray;
}



/* /////////////////////////////////////////////////////////////
	Adds minimap objects to scene using putAboveObject
	Called by render
	INPUT: none
	OUTPUT: array of objects to be removed from the scene after the minimap view is rendered
 *//////////////////////////////////////////////////////////////
function addMinimapObjects(){
	var removeObjects = new Array();

	//add yellow sphere for player
	var alphaMarker = new THREE.Mesh(
		new THREE.SphereGeometry( 20 ),
		new THREE.MeshBasicMaterial( {color: 0xffff00} )	
	);
	removeObjects = removeObjects.concat(putAboveObject(new Array(player), alphaMarker));

	// add red cube for powerups
	var minimapPowerups = [];
	var powerupCube = new THREE.Mesh(
		new THREE.BoxGeometry( 20, 20, 20 ),
		new THREE.MeshBasicMaterial( {color: 0xff0000} )
	);
	removeObjects = removeObjects.concat(putAboveObject(powerups, powerupCube));

	//add blue dodecahedron for collectibles
	var minimapCollectibles = [];
	var collectibleDodec = new THREE.Mesh(
		new THREE.DodecahedronGeometry( 20 ),
		new THREE.MeshBasicMaterial( {color: 0x0000ff} )
	);
	removeObjects = removeObjects.concat(putAboveObject(collectibles, collectibleDodec));

	return removeObjects;
}


/* /////////////////////////////////////////////////////////////
	Removes given objects from the scene
	Called by render
	INPUT: array of objects to be removed
	OUTPUT: none
 *//////////////////////////////////////////////////////////////
function removeMinimapObjects( removeObjects ){
		for(var i = 0; i < removeObjects.length; i++){
			scene.remove(removeObjects[i]);
		}
}



/* /////////////////////////////////////////////////////////////
	The render function draws the scene.
	Called every frame and by init
	INPUT: none
	OUTPUT: none
 *//////////////////////////////////////////////////////////////
function render() {

	// Render main camera on entire screen
	cameraRender (mainCamera, 0, 0, window.innerWidth, window.innerHeight)	

	//if paused don't show minimap
	if(animating){
		scene.remove(worldMap.atmosphere);
		//add objects to minimap so it will be easier to see
		var removeObjects = addMinimapObjects();
		// Render minimap camera in top right corner
		cameraRender(minimapCamera, window.innerWidth - minimapWidth - 50, 20, minimapWidth, minimapHeight);
	
		// remove objects from minimap
		removeMinimapObjects(removeObjects);
		scene.add(worldMap.atmosphere)
	}
}

/* /////////////////////////////////////////////////////////////
	Creates random lights, Amount is specified when creating level. Lights are Point lights with shadows enabled
	Called from createWorld
	INPUT: none
	OUTPUT: none - this function adds lights directly to the scene
 *//////////////////////////////////////////////////////////////
function createRandomLights(){
	for(var i = 0; i < level.numRandomLights; i++){
		var light = new THREE.PointLight(0xffffff, 1, 1000000);
		light.position.set(
			Math.pow(-1, Math.floor(Math.random() * 2) + 1) * level.worldWidth / (6 + Math.random() * 10),
			level.atmosphereHeight * (1 + Math.random()), 
			Math.pow(-1, Math.floor(Math.random() * 2) + 1) * level.worldWidth / (6 + Math.random() * 10)
		);

		//shadows for light 1
		light.castShadow = true;
		light.shadowDarkness = 0.5;
		//Set up shadow properties for the light
		light.shadow.mapSize.width = level.worldWidth;  
		light.shadow.mapSize.height = level.worldDepth; 
		light.shadow.camera.near = 0.5;    // default
		light.shadow.camera.far = Math.sqrt(Math.pow(level.atmosphereHeight,2) + Math.pow(Math.pow(level.worldWidth,2) + Math.pow(level.worldDepth,2),2));     // Pythagoras equation for edge to edge diagonal of livable map cube

		scene.add(light);
	}
}

/* /////////////////////////////////////////////////////////////
	This function takes a number and splits it randomly into numParts parts.
	Called from createPowerups
	INPUT: num - number to be split, numParts - amount of sections to dplit the number to
	OUTPUT: none - this function adds lights directly to the scene
 *//////////////////////////////////////////////////////////////
function splitNumToParts(num, numParts){
	var numPerSplit = []; 
	var currNum = num;
	for(var i = 0; i < numParts -1; i++){
		var currAmount = Math.floor(Math.random() * currNum);
		numPerSplit.push(currAmount);
		currNum -= currAmount;
	}
	numPerSplit.push(currNum);

	return numPerSplit;
}

/* /////////////////////////////////////////////////////////////
	This function adds powerups to the scene. Amount of powerups specified when creating level.
	The different powerups are chosen with random probability
	Called when adding powerups  in createWorld
	INPUT: none
	OUTPUT: none - this function adds powerups directly to the scene
 *//////////////////////////////////////////////////////////////
function createPowerups(){
	var powerupsSplit = splitNumToParts(level.numPowerups, powerupTypes.length);
	console.log("Powerups Split: " + powerupsSplit);

	
	for(var i = 0; i < powerupTypes.length; i++){
		for(var j = 0; j < powerupsSplit[i]; j++){
			powerups.push(new Powerup(i));
		}
	}
	// move powerups to random place on map
	randomMoveArray(powerups);

	for(var i = 0; i < powerups.length; i++){
		scene.add(powerups[i]);
	} 
}

/* /////////////////////////////////////////////////////////////
	This function adds collectibles to the scene. Amount of collectibles specified when creating level.
	Called when adding collectibles in createWorld
	INPUT: none
	OUTPUT: none - this function adds collectibles directly to the scene
 *//////////////////////////////////////////////////////////////
function createCollectibles(){
	for(var i = 0; i < level.numCollectibles; i++){
		collectibles.push(new Collectible(
				new THREE.CylinderGeometry(1,0.5,1,32),
				new THREE.MeshPhongMaterial({color: 0xff00ff})
			)
		);
	}
	// move collectibles to random place on map
	randomMoveArray(collectibles);

	for(var i = 0; i < collectibles.length; i++){
		scene.add(collectibles[i]);
	}
}


/* /////////////////////////////////////////////////////////////
	Creates the world map, lights, cameras, player and collectibles and powerups.
	Called by restartGame and init.
	INPUT: none
	OUTPUT: none
 *//////////////////////////////////////////////////////////////
function createWorld() {
    renderer.setClearColor("black"); // Background color for scene.
    scene = new THREE.Scene();
    scene.add(player);
  
	createMenus();


    // -------------------------------------- MAKE MAIN CAMERA -------------------------------------
    mainCamera = new THREE.PerspectiveCamera(
		30, 
		window.innerWidth/window.innerHeight, 
		0.1, 
		level.alphaCameraDistance * 20
	);
  	mainCamera.position.z = level.alphaCameraDistance;
  	player.add(mainCamera);


	//-------------------------------------------- LIGHTING ------------------------------------------------
	createRandomLights();
	var viewLight = new THREE.PointLight(0xff00ff, 1);
	player.add(viewLight);
	viewLight.position.z = level.alphaCameraDistance;
    

	//------------------------------------------ MINIMAP ----------------------------------------------
	minimapCamera = new THREE.OrthographicCamera(		// Orthographic camera does not change according to distance, which is what we want
	    window.innerHeight / -5,						// Left
		window.innerHeight / 5,							// Right
    	window.innerHeight / 5,							// Top
    	window.innerHeight / -5,						// Bottom
    	-3 * level.atmosphereHeight,					// Near 
    	10000 );           								// Far 
	minimapCamera.up = new THREE.Vector3(0,0,-1);		// COMMENT
	minimapCamera.lookAt( new THREE.Vector3(0,-1,0) );	// COMMENT
	scene.add(minimapCamera);							// Add minimap camera to scene



    //---------------------------------- CREATE THE WORLD ------------------------------------------- 
	worldMap = new Map(level.worldWidth, level.worldDepth, level.atmosphereHeight, level.floorTextureURL, level.backgroundURL, level.buildingModelURLs) //width, height, atmosphereHight, textureURL, skyboxDirectory

	scene.add(worldMap.floor);
	scene.background = worldMap.background;
	scene.add(worldMap.atmosphere);	
	//add buildings to scene
	worldMap.createBuildings(level.mapBuildingRatio); 

	for (var i = 0; i < worldMap.buildings.length; i++){
		scene.add(worldMap.buildings[i]);
	}


	
    //---------------------------------- Dynamic Sculpture -------------------------------------------
    // TODO: try cubecamera on lab computers
	// resources: http://learningthreejs.com/blog/2014/05/12/live-cube-maps-reflections-in-your-three-dot-js-game-with-threex-dot-cubecamera/
	
	joshSucks = new THREE.Object3D();		// Sculpture object

	// Make a reflective sphere (only reflects skybox, at the moment)
	var geometry = new THREE.SphereGeometry(5, 32, 16);
	var material = new THREE.MeshPhongMaterial({
    color   : 'chrome',
	envMap 	: scene.background
	});
	discoBall = new THREE.Mesh(geometry, material); 
	discoBall.position.set(0,0,0);	// centre obj coords of sphere
	joshSucks.add(discoBall);
		

//////////////////////////////////////////////////////////////////////////////////
//		add  text	 														//
///	///////////////////////////////////////////////////////////////////////////////
	text = "JOSH  SUCKS";
	text_height = 0.5;
	text_size = 2;
	curveSegments = 4;
	font = undefined;
		
	text_object_container = new THREE.Group();	
	text_object_container.position.set(-8,0,7);	// textObject translation onto sphere. Currently doesn't reflect close objects nicely 
	loadFont();

	joshSucks.add(text_object_container);
	joshSucks.rotateZ(0.2);
	var temp_test = player.position.clone();
	joshSucks.position.set(3,3,-2);
	scene.add(joshSucks);



	//----------------------------------- CREATE THE PLAYER --------------------------------------------

	// alpha is created by modelLoader function and added to player
	
	var loader = new THREE.JSONLoader();					// create loader for .js models

	loader.load(level.alphaModelURL, modelLoader);			// load model and call model_loader
	
//------------------------------------- CREATE POWERUPS -----------------------------------------------
	createPowerups();
//--------------------------------------- CREATE COLLECTIBLES ------------------------------------------------
	createCollectibles();

} // end function createWorld()



/*//////////////////////////////////////////////////////////////////////////
	Model Loader function for alpha object. Creates alpha, places it in the scene and sets up animation
	Callback function for JSON loader in createWorld()
	INPUT: THREE geometry and material objects
	OUTPUT: none
///////////////////////////////////////////////////////////////////////////*/
function modelLoader(geometry, materials) {

	var material = new THREE.MeshLambertMaterial( {
        vertexColors: THREE.FaceColors,  			// use colors from the geometry
        morphTargets: true							// for animation
    });
	alpha = new Alpha(geometry,material, 1);		// create alpha object
	
// TRANSFORMS
	alpha.scale.set(0.05,0.05,0.05);
	alpha.position.set(0,0,0);
	alpha.rotateY(Math.PI);
	alpha.castShadow = true;
	player.add(alpha);								// add alpha to player
	player.translateY(10);							// move player so that alpha doesn't crash on game start

	alpha.geometry.computeBoundingBox();			// Get bounding box for model, for doing collisions
	alphaDone = true;
	alpha.startup();


// ANIMATION STUFF
	mixer = new THREE.AnimationMixer( alpha );
	var clip = THREE.AnimationClip.CreateFromMorphTargetSequence( 'motion', geometry.morphTargets, 30 );
    var animationAction = mixer.clipAction(clip);
    animationAction.setDuration(1);
    animationAction.play(); 
	render();
}

// END OF INITIALISATION



/*<<<<<<<<<<<<<<<<<<<<<< C U S T O M 	S U B   R O U T I N E S >>>>>>>>>>>>>>>>>>>>>>>>>>>
			                                 |_
			                           _____|~ |____
			                          (  --         ~~~~--_,
			                           ~~~~~~~~~~~~~~~~~~~'`  

*/



/*///////////////////////////////////////////////////////////////////////////////// 
	Gets a random vector for a new position.
	Called by randomMoveArray
	INPUT: none
	OUTPUT: THREE.Vector3 with the new randomised position
//////////////////////////////////////////////////////////////////////////////////*/
function randomPlace(){
	var move = [];
	move.push(Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * (worldMap.width / 2));
	move.push(Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * worldMap.atmosphereHeight + 5);
	move.push(Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * (worldMap.depth / 2));
	return new THREE.Vector3(move[0],move[1],move[2]);

}

/*///////////////////////////////////////////////////////////////////////////////// 
	For every object in the input array, calls randomPlace to get a new random position, places the object in that position, then finds a new position until it is no longer colliding with another object
	Called in createWorld for the collectibles and powerups
	INPUT: array of objects to place in random positions
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function randomMoveArray( arr ){
	for(var i = 0; i < arr.length; i++){
		var move = randomPlace();
		arr[i].position.set(move.x, move.y, move.z);
		arr[i].geometry.computeBoundingBox();
		while(buildingBoxCollision(arr[i]).length != 0){
			move = randomPlace();
			arr[i].position.set(move.x, move.y, move.z);
		}
	}
}


/*///////////////////////////////////////////////////////////////////////////////// 
	Reset the camera's to be behind the player (chase cam), after viewing the world.
	Called by 
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function resetCameraPosition(){
	var cameraRotationSpeed = 0.1;
	mainCamera.translateX((alpha.position.x - mainCamera.position.x) * cameraRotationSpeed);
	mainCamera.translateY((alpha.position.y - mainCamera.position.y) * cameraRotationSpeed);
	mainCamera.translateZ((alpha.position.z + level.alphaCameraDistance - mainCamera.position.z) * cameraRotationSpeed);
	mainCamera.lookAt(alpha.position);

	if(Math.abs(alpha.position.x - mainCamera.position.x) <= 0.01 &&
		Math.abs(alpha.position.y - mainCamera.position.y <= 0.01) &&
		Math.abs(alpha.position.z + level.alphaCameraDistance - mainCamera.position.z <= 0.01)){
		
		resetCameraFlag = false;
	}
}


//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< M E N U   F U N C T I O N S >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
/*///////////////////////////////////////////////////////////////////////////////// 
	Returns the current open menu
	Called by menuInteraction and keysPressed
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function openMenu(){
	var menu;
	if(menusArr.startMenu.isOpen){
		menu = menusArr.startMenu;
	} else {
		menu = menusArr.pauseMenu;
	}
	return menu;
}


/*///////////////////////////////////////////////////////////////////////////////// 
	Exits the menu.
	Called by exitMenu and menuInteraction
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function exitMenu(){
	var menu = openMenu();
	
	console.log("exiting menu");
	scene.remove(menu.skybox);
	for(var i = 0; i< menu.buttons.length; i++){
		scene.remove(menu.buttons[i]);
	}
	
	menu.isOpen = false;
	document.removeEventListener("mousedown", menuInteraction);
}


/*///////////////////////////////////////////////////////////////////////////////// 
	Uses raycasting to check which menu box the user clicks
	Callback function for mouseclick event listener in displayMenu
	INPUT: click event
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function menuInteraction(e){
	var raycaster = new THREE.Raycaster();
	var menu = openMenu();

	//var r = window.getBoundingClientRect();
	var x = e.clientX							// take in click coordinates
	var y = e.clientY	// 

	var a = 2 * x / window.innerWidth - 1; // convert canvas pixel coords to clip coords
	var b = 1 - 2 * y / window.innerHeight;

	raycaster.setFromCamera( new THREE.Vector2(a,b), mainCamera );		//COMMENT

	var intersections = raycaster.intersectObjects( menu.buttons, true );
	if(intersections.length >= 1){
		if(intersections[0].object.name == "restart_button"){
			console.log("restarting game");
			exitMenu();
			restartGame();
		} else if(intersections[0].object.name == "start_button"){
			console.log("starting game");
			exitMenu();
			animating = true;
			requestAnimationFrame(doFrame);
		} else if (intersections[0].object.name == "resume_button"){
			console.log("resuming game");
			exitMenu();
			animating = true;
			requestAnimationFrame(doFrame);
		} else if(intersections[0].object.name == "exit_button"){
			window.alert("This is, sadly, a web game.\nIf you want to close it you are welcome to close this browser tab.\nJust know that it cannot be proven that exiting this game will not result in you being dead one month later\nYou have been warned");
		}
	}
}

/*////////////////////////////////////////////////////////////////////////////////
	Display pause menu, sets position of menu skybox and buttons and places them in the scene, makes an event listener for mouseclicks
	Called by keysPressed when the 'p' key is pressed
	INPUT: none
	OUTPUT: none
/////////////////////////////////////////////////////////////////////////////////*/
function displayMenu(menu){
	menu.isOpen = true;
	menu.skybox.position.x = player.position.x;
	menu.skybox.position.y = player.position.y;
	menu.skybox.position.z = player.position.z;
	scene.add(menu.skybox);

	for(var i = 0; i < menu.buttons.length; i++){
		menu.buttons[i].position.x = player.position.x + Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * ((level.alphaCameraDistance * 2 - 5) / 2);
		menu.buttons[i].position.y = player.position.y +  Math.random() * ((level.alphaCameraDistance * 2 - 5) / 2);
		menu.buttons[i].position.z = player.position.z + Math.pow(-1, Math.floor(Math.random() * 2 + 1)) * Math.random() * ((level.alphaCameraDistance * 2 - 5) / 2);

		scene.add(menu.buttons[i]);
	}

	console.log("displaying menu...");

	document.addEventListener("mousedown", menuInteraction, false);
}

//END OF MENU FUNCTIONS


/*//////////////////////////////////////////////////////////////////////////
 Keyboard key lookups:  Check arrow, a,w,s,d and space keys
///////////////////////////////////////////////////////////////////////////*/

window.addEventListener("keydown", keysPressed, false);
window.addEventListener("keyup", keysReleased, false);

function key_check(){
	//keycodes taken from: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes	

	// Up Arrow or "w" - camera moves forwad = speed up
	if(keys[38] || keys[87]){ 
		alpha.incSpeedZ(-0.05);
	}
    // Down Arrow or "s" - camera moves back = speed down
    if(keys[40] || keys[83]){  
		alpha.incSpeedZ(0.05);
	}

    // a key: strafe left
    if (keys[65]) {     
        player.translateX(-0.2);
    }

    // d key: strafe right
    if (keys[68]) {     
        player.translateX(0.2);
    }

    // right arrow: turn right
    if (keys[39]) {     
        player.rotateY(-1 * Math.PI/180);
		minimapCamera.rotateZ(-1 * Math.PI/180);
    }

    // left arrow: turn left
    if (keys[37]) {     
        player.rotateY(Math.PI/180);
        // Rotate the model (in it's Euler angles)
        while(i < 0.3){
        	//alpha.rotateZ(-i);
        	alpha.rotation.z = Math.PI/2;
        	i += 0.1;
        }
		minimapCamera.rotateZ(Math.PI/180) ;
    }

   // space key: fight gravity
   if (keys[90]) {     
		if (!jumping) {			// Set limit on jumping
			alpha.incSpeedY(1);
		}
		jumping = true;
    }
}

// This function gets called when a key is pressed
function keysPressed(e) {
	// "p" for pause and play           
	if(e.keyCode == 80){
		if(!animating){
			exitMenu();
			animating = true;
			requestAnimationFrame(doFrame);
		} else {
			animating = false;
			displayMenu();
		}
		return;
	}

	// F11 to enter and exit fullscreen
	if(e.keyCode == 122){
		if(!fullscreen){
			fullscreen = true;
			document.requestFullscreen();
		} else {
			fullscreen = false
			document.exitFullscreen();
		}
		return;
	}

	// F5 to refresh page
	if(e.keyCode == 116){
		window.location.reload(false); 
		return
	}
	
    // store an entry for every key pressed
    keys[e.keyCode] = true;
        // NB: prevent default browser behavior - disable during testing
        //e.preventDefault();
}

function keysReleased(e) {
    // mark keys that were released
    keys[e.keyCode] = false;
    if (e.keyCode == 90) {
		jumping = false;
	}
	/// reverse model rotation animation
	if(e.keyCode == 37){
		while((0.3 - i) < 0.3 ){
			i -= 0.1;
		}
		i=0;	// reset i so it can be used again
		alpha.rotation.z = Math.PI;
	}
}



/*///////////////////////////////////////////////////////////////////////////////////
	Reinitialize global variables
	Called by restartGame
	INPUT: none
	OUTPUT: none
////////////////////////////////////////////////////////////////////////////////////*/
function reinitializeGlobals(){
	scene = null;
	mainCamera = null;
	frameNumber = 0;
	animating = false;
	player = new THREE.Object3D();
	keys = []; 								// records current keys being pressed
	resetCameraFlag = false 				// flag to reset the camera position to original position
	jumping = false;						// whether player is jumping or not
	alpha = null;							// player stats tracking + model  object
	gameOver = false; 						// updates to true when lives == 0
	worldMap = null;                        // make global so it can be accessed by collision function
	powerups = [];							// items providing certain powerups or "boosts" to the player for a short time when picked up
	activePowerup = null;
	collectibles = [];						// the items that the player needs to collect in order to progress to the next level
	//var collectiblesLeft = 0;				// the number of collectibles left to collect. when this reaches zero, go to next level
	mixer = null;  							// The object that animates the model, of type THREE.AnimationMixer
	minimapCamera = null; 
	worldMap = null;
	//joshSucks = null; 						// he does
	Score = 0;
	i=0;
}



/*///////////////////////////////////////////////////////////////////////////////////
	Restart game - reset all alpha variables, reload all models, respawn alpha at origin
	Called by Crash when the player crashes and has no more lives, menuInteraction when the restart game option is chosen and collisions when all collectibles are found
	INPUT: none
	OUTPUT: none
////////////////////////////////////////////////////////////////////////////////////*/
function restartGame(){
	console.log("restarting game");
	level.reinitializeGlobals();
	createWorld();
	installOrbitControls();
	console.log("game restarted");	
}



/*//////////////////////////////////////////////////////////////////////////
	Reduce player Y speed for for gravity and make them crash if they touch the floor
	Called by updateForFrame every frame
	INPUT: none
	OUTPUT: returns false if the player crashes and true if they dont
///////////////////////////////////////////////////////////////////////////*/
function putOnFloor() {
	if(player.position.y > worldMap.floorHeight + alpha.getRadius() - 2) {			//check if player has reached the "floor" + some leeway
		alpha.incSpeedY(-0.01);																		//if they have not, reduce speed (gravity)
		return true;
	} else {																		//if they have, the player crashes
		Crash();
		return false;
	}	
}



/*//////////////////////////////////////////////////////////////////////////
	Crash: Explosion, respawn from crash site, decrement lives, game over
	Called by colllisions, updateForFrame and putOnFloor
	INPUT: none
	OUTPUT: none
///////////////////////////////////////////////////////////////////////////*/
function Crash() {
	// Update Alpha stats
	alpha.lives -= 1;
	
	// if no more lives, game over
	if (alpha.lives == 0){
		animating = false;
		window.alert("G A M E    O V E R\nYour final score: " + Score + "\nClick OK to start a new game");
		restartGame();
	}else{
	// TODO : Crash animation, respawn
		console.log("alpha crashed...");
		animating = false;
		window.alert("C R A S H E D!\n Lives left: " + alpha.lives);
		alpha.respawn();
	}
}



//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< C O L L I S I O N S ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


/*///////////////////////////////////////////////////////////////////////////////// 
	Check for collision between two bounding boxes. Note bounding boxes have min: x,y,z, and max: x,y,z values
	Called by buildingBoxCollision
	INPUT: two objects
	OUTPUT: returns true if their is a collision, false otherwise
//////////////////////////////////////////////////////////////////////////////////*/
function twoBoxCollision(box1, box2){
	if(
		(box1.max.x < box2.min.x || box1.min.x > box2.max.x) ||
		(box1.max.y < box2.min.y || box1.min.y > box2.max.y) ||
		(box1.max.z < box2.min.z || box1.min.z > box2.max.z) 
	){
		return false;
	}
	return true;
}


/*///////////////////////////////////////////////////////////////////////////////// 
	This function checks for collision of bounding boxes of alpha and the map buildings
	Called by collisions and randomMoveArray
	INPUT: object to check collision with
	OUTPUT: object array of suspected collisions with input objects
//////////////////////////////////////////////////////////////////////////////////*/
function buildingBoxCollision( object ){
	var suspectObjects = [];
	var objectBox = new THREE.Box3();
    objectBox.setFromObject( object );		//Computes the world-axis-aligned bounding box of an Object3D (including its children), accounting for the object's, and children's, world transforms

	for(var i = 0; i < worldMap.buildingBoxes.length; i++){
		if(twoBoxCollision(worldMap.buildingBoxes[i], objectBox)){
			suspectObjects.push(worldMap.buildings[i]);
		}
	}
	return suspectObjects;
}


/*////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
	Function to check for collisions between player and buildings, collectibles and powerups
	Called by updateForFrame and alpha.respawn
	INPUT: none
	OUTPUT: none
	credit: // https://github.com/stemkoski/stemkoski.github.com/blob/master/Three.js/Collision-Detection.html
///////////////////////////////////////////////////////////////////////////////////////////////////////////////*/
function  collisions() {
	var originPoint = player.position.clone();					// players position
	var suspectObjects = buildingBoxCollision(alpha);

	for (var vertexIndex = 0; vertexIndex < alpha.geometry.vertices.length; vertexIndex++){		
		var localVertex = alpha.geometry.vertices[vertexIndex].clone();
		var globalVertex = localVertex.applyMatrix4( alpha.matrix );
		var directionVector = globalVertex.sub( alpha.position );
		var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize() );
		var BuildingCollisionResults = ray.intersectObjects( suspectObjects , true );
		var PowerupsCollisionResults = ray.intersectObjects(powerups);
		var CollectibleCollisionResults = ray.intersectObjects(collectibles);
		
		// Check building collisions
		if ( 
			BuildingCollisionResults.length > 0 &&
			BuildingCollisionResults[0].distance < directionVector.length() - 1 &&
			!BuildingCollisionResults[0].point.equals(new THREE.Vector3(0,0,0))
		){ // TODO: adjust this offset (-1 currently)
			console.log("hit");
			Crash();
			break;
		}

		// Check Powerups[] collisions: if powerup 0,1,2 do stuff to alpha.stats, delete power up from powerupsarray, and remove from scene (maybe with a fancy animation):

		if (PowerupsCollisionResults.length > 0 && PowerupsCollisionResults[0].distance < directionVector.length()){
			//Check what type of powerup it was
			if(PowerupsCollisionResults[0].object.type == powerupTypes["gun"]){
				console.log("Gun"); //TODO: update alpha stats
			}else if(PowerupsCollisionResults[0].object.type == powerupTypes["invisible"]){
				console.log("Invisible"); //TODO: update alpha stats
			}else if(PowerupsCollisionResults[0].object.type == powerupTypes["gravity"]){
				console.log("Gravity"); //TODO: update alpha stats
			}
			
			PowerupsCollisionResults[0].object.activatePower();
			activePowerup = PowerupsCollisionResults[0].object;
			powerups.splice(powerups.indexOf (PowerupsCollisionResults[0].object), 1 );
			scene.remove(PowerupsCollisionResults[0].object);
		}
		
		// Check the Collectibles[] collisions: much like the powerups check above:
		if ( CollectibleCollisionResults.length > 0 && CollectibleCollisionResults[0].distance < directionVector.length() ){ 
			console.log(collectibles.indexOf (CollectibleCollisionResults[0].object) );
			collectibles.splice(collectibles.indexOf (CollectibleCollisionResults[0].object), 1 );
			scene.remove(CollectibleCollisionResults[0].object);
			
			if(collectibles.length == 0) {
				window.alert( "You won the level!");
				currLevel++;
				restartGame();
				return;
				//TODO: win the level if all collectibles collected
			}
		}

	}// end for loop	

} // end collision function

//END OF COLLISION FUNCTIONS


/*//////////////////////////////////////////////////////////////////////////
Fucking Text!
///////////////////////////////////////////////////////////////////////////*/


// get the font then run create text fn
// kind of redundant
// TODO: fix redundancy 
function loadFont() {
	var loader = new THREE.FontLoader();
	loader.load( 'fonts/Etienne/helvetiker_regular.typeface.js', function ( response ) {

		font = response;		// This is simply the URL of the font
		console.log("loadFont:" ,response);
		createText();			// Calls the text_geometry making function

	} );
}


// create text fn
// note: I tried changing this to take in text text,height,size etc, but javascript didn't like that
// main problem is returning the mesh...doesn't work out/ no time to think about it
function createText() {
	console.log("createText()");
	var textGeo = new THREE.TextGeometry( text, {			// This is where we actually pass in the required text.
		font: font,
		size: text_size,
		height: text_height,
		curveSegments: curveSegments
	});

	textGeo.computeBoundingBox();
	textGeo.computeVertexNormals();

	// "fix" side normals by removing z-component of normals for side faces
	// (this doesn't work well for beveled geometry as then we lose nice curvature around z-axis)
	var triangleAreaHeuristics = 0.1 * ( text_height * text_size );

	for ( var i = 0; i < textGeo.faces.length; i ++ ) {

		var face = textGeo.faces[ i ];

		if ( face.materialIndex == 1 ) {

			for ( var j = 0; j < face.vertexNormals.length; j ++ ) {

				face.vertexNormals[ j ].z = 0;
				face.vertexNormals[ j ].normalize();

			}

			var va = textGeo.vertices[ face.a ];
			var vb = textGeo.vertices[ face.b ];
			var vc = textGeo.vertices[ face.c ];

			var s = THREE.GeometryUtils.triangleArea( va, vb, vc );

			if ( s > triangleAreaHeuristics ) {

				for ( var j = 0; j < face.vertexNormals.length; j ++ ) {

					face.vertexNormals[ j ].copy( face.normal );
				}
			}
		}
	}

	var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );
	
	var Text_materials = [														
	new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } ), 	// front material
	new THREE.MeshPhongMaterial( { color: 0xffffff } ) 						// side material
	];
	textMesh1 = new THREE.Mesh( textGeo, Text_materials );
	//////////////////////////////////////////////////////////////////////////////////
	// Bend text
	// Source: https://github.com/alexan0308/threejs/blob/master/examples/webgl_simple_modifiers.html
	//////////////////////////////////////////////////////////////////////////////////
	
	var direction = new THREE.Vector3( 0, 0, -1 );
	var axis =  new THREE.Vector3( 0, 1, 0 );		// axis to bend in
	var angle = Math.PI / 3;
	var modifier = new THREE.BendModifier();
	modifier.set( direction, axis, angle ).modify( textMesh1.geometry );
	text_object_container.add(textMesh1);
	
	//////////////////////////////////////////////////////////////////////////////////
	// Make text glow
	// source: https://github.com/jeromeetienne/threex.geometricglow
	//////////////////////////////////////////////////////////////////////////////////

	var glowMesh	= new THREEx.GeometricGlowMesh(textMesh1);
	text_object_container.add(glowMesh.object3d);

	//////////////////////////////////////////////////////////////////////////////////
	//		customize glow mesh if needed											//
	//////////////////////////////////////////////////////////////////////////////////

	var insideUniforms	= glowMesh.insideMesh.material.uniforms
	insideUniforms.glowColor.value.set('hotpink')
	var outsideUniforms	= glowMesh.outsideMesh.material.uniforms
	outsideUniforms.glowColor.value.set('hotpink')
	
}	// end createText



///////////////////////////////////\				  //////////////////////////////
//================================== end sub routines =============================
///////////////////////////////////////////////////////////////////////////////////



/*///////////////////////////////////////////////////////////////////////////////// 
	Updates frame by moving player, moving minimap camera, crashing player if they move above atmosphere or below floor, update animations, increment score and check for collisions
	Called by doFrame
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function updateForFrame() {

	//Move player backwards or forwards by their Z velocity
    player.translateZ(alpha.getSpeedZ());	

    //Move player up or down by their Y velocity
	player.translateY(alpha.getSpeedY());

	// move minimap camera on x,z axis according to player
	// minimap height stays constant right and captures from right bellow the atmosphere
	minimapCamera.position.set(player.position.x, minimapCamera.position.y, player.position.z);	

	// Put player on floor if they aren't already on it.
	if(!putOnFloor()){
		return;
	}

	//check for death by atmosphere (lasers) (height) + some leeway
	if(player.position.y > level.atmosphereHeight + 1){
		Crash();
		return;
	}

	// Slowly moving the camera back behind _alpha_
	if (resetCameraFlag){
		resetCameraPosition();
	}

	// Animate power-ups
	for(var i = 0; i < powerups.length; i++){
		powerups[i].animate();
	} 
	
//check if a power has been activated
	if(activePowerup != null) {
		if(activePowerup.getExpiration() < 0) {
			activePowerup.deactivatePower();
			activePowerup = null;
		} else {
			activePowerup.decrementExpiration();
		}
		
	}
	
	// animate collectibles
	for(var j = 0; j < collectibles.length; j++) {
		collectibles[j].animate();
	}

	// update model animation
	if(mixer) {
		mixer.update(0.02);
	}

	// camera can't got below floor
	if(new THREE.Vector3().setFromMatrixPosition(mainCamera.matrixWorld).y < worldMap.floorHeight + 0.1){
		mainCamera.position.y = worldMap.floorHeight + 1.1;
	}
	
	// Summon keyboard control lookups in one line.
	keyCheck(); 		

	//Collision
	collisions();
	if(alpha == null){
		return;
	}

	//animate josh sucks
	joshSucks.rotateY(Math.sin(Math.PI/6));

	// update cube map reflections. TODO: Only do this if the object is visible/ in 'range'
	//cubeCamera.update(renderer, scene);
	
	// Score update: TODO: ut in function and tidy up
	if(Math.abs(player.position.x) <= level.worldWidth / 2 && Math.abs(player.position.z) <= level.worldDepth){
		console.log("player.position.x " + player.position.x + " player.position.z " + player.position.z)  
		console.log("level.worldWidth " + level.worldWidth + " level.worldDepth " + level.worldDepth)
		Score++;
	} else {
		Score = Score - 5;
	}

 	document.getElementById("s1").innerHTML = "Score: " + Score;
 	document.getElementById("s2").innerHTML = "Lives: " + alpha.lives; // this will need to go in Crash function maybe

}


//<<<<<<<<<<<<<<<<<<<<<<<<<<<<< MOUSE AND KEYBOARD SUPPORT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>


// Event listeners for keydown and keyup events
window.addEventListener("keydown", keysPressed, false);
window.addEventListener("keyup", keysReleased, false);

// keyboard control taken from: http://www.johannes-raida.de/tutorials/three.js/tutorial07/tutorial07.htm
// multiple keypresses from: https://www.kirupa.com/html5/keyboard_events_in_javascript.htm

/*///////////////////////////////////////////////////////////////////////////////// 
	Keyboard key lookups:  Check if arrow, a,w,s,d and space keys are down using keys array
	Called by updateForFrame
	keycodes taken from: https://www.cambiaresearch.com/articles/15/javascript-char-codes-key-codes	
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function keyCheck(){

	// Up Arrow or "w" - camera moves forwad = speed up
	if(keys[38] || keys[87]){ 
		alpha.incSpeedZ(-0.05);
	}
    // Down Arrow or "s" - camera moves back = speed down
    if(keys[40] || keys[83]){  
		alpha.incSpeedZ(0.05);
	}

    // a key: strafe left
    if (keys[65]) {     
        player.translateX(-0.2);
    }

    // d key: strafe right
    if (keys[68]) {     
        player.translateX(0.2);
    }

    // right arrow: turn right
    if (keys[39]) {     
        player.rotateY(-1 * Math.PI/180);
		minimapCamera.rotateZ(-1 * Math.PI/180);
    }

    // left arrow: turn left
    if (keys[37]) {     
        player.rotateY(Math.PI/180);
		minimapCamera.rotateZ(Math.PI/180) ;
    }

   // z key: fight gravity
   if (keys[90]) {
		if (!alpha.jumping) {			// Set limit on jumping
			alpha.incSpeedY(1);
		}
		alpha.jumping = true;
    }
}


/*///////////////////////////////////////////////////////////////////////////////// 
	This function gets called when a key is pressed
	Callback function for keydown event listener
	INPUT: keydown event e
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function keysPressed(e) {
	// "p" for pause and play           
	if(e.keyCode == 80){
		if(!animating){
			exitMenu();
			animating = true;
			requestAnimationFrame(doFrame);
		} else {
			animating = false;
			displayMenu(menusArr.pauseMenu);
		}
		return;
	}

	// F11 to enter and exit fullscreen
	if(e.keyCode == 122){
		if(!fullscreen){
			fullscreen = true;
			document.requestFullscreen();
		} else {
			fullscreen = false
			document.exitFullscreen();
		}
		return;
	}

	// F5 to refresh page
	if(e.keyCode == 116){
		window.location.reload(false); 
		return
	}
	
    // store an entry for every key pressed
    keys[e.keyCode] = true;
    // NB: prevent default browser behavior - disable during testing
    //e.preventDefault();
}

/*///////////////////////////////////////////////////////////////////////////////// 
	Callback function for keyup event listener
	INPUT: keyup event e
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function keysReleased(e) {
    // mark keys that were released
    keys[e.keyCode] = false;
    if (e.keyCode == 90) {
		alpha.jumping = false;
	}
}

 /*///////////////////////////////////////////////////////////////////////////////// 
	Uses THREE.OrbitControls from the graphics course to allow the user to rotate the view with the mouse
	Called by init and restartGame
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function installOrbitControls() {
    controls = new THREE.OrbitControls(mainCamera,canvas);
    controls.noPan = true; 
    controls.noZoom = true;
    controls.staticMoving = true;
    function move() {
        controls.update();
        if (! animating) {
            render();
        }
    }
    function down() {
        document.addEventListener("mousemove", move, false);
    }
    function up() {
        document.removeEventListener("mousemove", move, false);
    }
    function touch(event) {
        if (event.touches.length == 1) {
            move();
        }
    }
    document.addEventListener("mousedown", down, false);
    document.addEventListener("touchmove", touch, false);
}

// END OF MOUSE AND KEYBOARD FUNCTIONS


/*///////////////////////////////////////////////////////////////////////////////// 
	Drives the animation, called by system through requestAnimationFrame()
	Called by itself, exitMenu and keysPressed
	INPUT: none
	OUTPUT: none
//////////////////////////////////////////////////////////////////////////////////*/
function doFrame() {
    if (animating) {
        updateForFrame();
        render();
		stats.update();
        requestAnimationFrame(doFrame);
    }
}


 /*/////////////////////////////////////////////////////////////////////////////////////
	Creates the renderer, container for stats, scene object, calls createWorld and installOrbitControls. Renders initial view of the scene
	Called by onload event
	INPUT: none
	OUTPUT: none
 //////////////////////////////////////////////////////////////////////////////////////*/
function init() {
    try {
		container = document.getElementById( 'container' );
		document.getElementById("s0").innerHTML = "Level: " + level.levelNum;
		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMap.enabled = true;
		renderer.setScissorTest( true ); //important for minimap not to take control of entire screen even though it only occupies a corner
		//renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap

		container.appendChild( renderer.domElement );

		stats = new Stats();
		container.appendChild( stats.dom );
    }
    catch (e) {
        document.getElementById("message").innerHTML="<b>Sorry, an error occurred:<br>" +
                e + "</b>";
        return;
    }
    createWorld();
    installOrbitControls();

	document.addEventListener("mousedown", function(){resetCameraFlag = false}, false);
	document.addEventListener("mouseup", function(){resetCameraFlag = true}, false);	
    render();
}

</script>

<!-- CSS -->
<style>
.container {
    position: relative;
    text-align: center;
    color: black;
}

.bottom-left {
    position: absolute;
    bottom: 8px;
    left: 16px;
}

.top-left {
    position: absolute;
    top: 8px;
    left: 16px;
}

.top-right {
    position: absolute;
    top: 8px;
    right: 16px;
}

.bottom-right {
    position: absolute;
    bottom: 8px;
    right: 16px;
}

.centered {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.text-block {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background-color:rgba(192,192,192,0.5);
    color: white;
    padding-left: 20px;
    padding-right: 20px;
}

</style>


</head>
<body onload="init()">


	<noscript>
   		<p style="color: #AA0000; font-weight: bold">Sorry, but this page requires JavaScript!</p>
	</noscript>

	<p style="color:#AA0000; font-weight: bold" id="message"> </p>
 	<div class="container">
		<div id="container"></div>
	  	<div class="text-block">
	    	<h4>Stats</h4>
	    	<p id="s0"></p>
	    	<p id="s1">Score: NaN </p>
	    	<p id="s2">Lives: - / - </p>
	    </div>
	</div>

</body>
</html>
